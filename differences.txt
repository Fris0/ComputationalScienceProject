diff --git a/physics.py b/physics.py
index de106cc..ac5a79a 100644
--- a/physics.py
+++ b/physics.py
@@ -75,11 +75,12 @@ class Rocket():
         self.Mr_a = 131.0      # total propellant mass in Apache after Nike burnout (lbs)
         self.Mp_a = 217.0      # rocket mass after Nike detaches (lbs)
         self.A_a = 0.239      # cross-sectional area (ft^2) after Nike detaches
-        self.T_n = 42500.0      # thrust of Nike (lbf)
+        self.T_n = T      # thrust of Nike (lbf)
         self.I_n = self.T_n * self.t_b_n  # Total impulse of Nike (lb-sec)
         self.T_a = 5130.0       # Thrust of Apache (lbf)
         self.I_a = 32800.0      # Total impulse of Apache (lb-sec)
         self.mass_flow_apache = self.Mr_a / self.t_b_a  # Apache Mass flow rate (lbs/sec)
+        self.impact = False
 
     def rocket_1d_dynamics(self, t, state):
         """
@@ -136,7 +137,14 @@ class Rocket():
         # Unpack state
         x, y, vx, vy, m = state
 
-        h = np.sqrt(x**2 + y**2)
+        # Determines the height the rocket is at.
+        h = np.sqrt((x-0)**2 + (y+self.Re)**2) - self.Re # Model the earth like a circle of radius self.Re centered at (0, -self.Re)
+
+        if h < 0:
+            self.impact = True
+
+        if self.impact:
+            return np.array([0, 0, 0, 0, 0])
 
         # Decide if rocket is still burning
         if t < self.t_b:
@@ -148,12 +156,11 @@ class Rocket():
             thrust = 0.0
             mdot = 0.0
 
-        # Inverse-square law: g(y) = g0 * (Re / (Re + y))^2
-        g_local = self.g * (self.Re / (self.Re + y))**2 if (self.Re + y) > 0 else self.g
+        # Inverse-square law: g(y) = g0 * (Re / (Re + h))^2
+        g_local = self.g * (self.Re / (self.Re + h))**2 if (self.Re + h) > 0 else self.g
 
         # Flight angle from vertical
-        dist = np.sqrt(x**2 + y**2)
-        if dist < 2:
+        if h < 2:
             fa = self.la
         else:
             fa = np.arctan2(vy, vx)
@@ -177,9 +184,17 @@ class Rocket():
         Fx_thrust = thrust * np.cos(fa)
         Fy_thrust = thrust * np.sin(fa)
 
+        # Gravity forces
+        if (x**2 + y**2) > 0:
+            Fx_gravity = x/np.sqrt(x**2 + y**2) * (-m * g_local)
+            Fy_gravity = y/np.sqrt(x**2 + y**2) * (-m * g_local)
+        else:
+            Fx_gravity = 0
+            Fy_gravity = 0
+
         # Net forces
-        Fx_net = Fx_drag + Fx_thrust
-        Fy_net = Fy_drag + Fy_thrust + (-m * g_local)
+        Fx_net = Fx_drag + Fx_thrust + Fx_gravity
+        Fy_net = Fy_drag + Fy_thrust + Fy_gravity
 
         # Accelerations
         ax = Fx_net / m
@@ -200,7 +215,14 @@ class Rocket():
         # Unpack state
         x, y, vx, vy, m = state
 
-        h = np.sqrt(x**2 + y**2)
+        # Determines the height the rocket is at.
+        h = np.sqrt((x-0)**2 + (y+self.Re)**2) - self.Re # Model the earth like a circle of radius self.Re centered at (0, -self.Re)
+
+        if h < 0:
+            self.impact = True
+
+        if self.impact:
+            return np.array([0, 0, 0, 0, 0])
 
         # Stage 1 Nike Burn and Detach
         if t < self.t_b_n:
@@ -230,7 +252,10 @@ class Rocket():
         g_local = self.g * (self.Re / (self.Re + h)**2) if (self.Re + h) > 0 else self.g
 
         # Flight angle from vertical
-        fa = np.arctan2(vx, vy)
+        if h < 2:
+            fa = self.la
+        else:
+            fa = np.arctan2(vy, vx)
 
         speed = np.sqrt(vx**2 + vy**2)
         if speed > 1e-12:
@@ -251,9 +276,17 @@ class Rocket():
         Fx_thrust = thrust * np.cos(fa)
         Fy_thrust = thrust * np.sin(fa)
 
+        # Gravity forces
+        if (x**2 + y**2) > 0:
+            Fx_gravity = x/np.sqrt(x**2 + y**2) * (-m * g_local)
+            Fy_gravity = y/np.sqrt(x**2 + y**2) * (-m * g_local)
+        else:
+            Fx_gravity = 0
+            Fy_gravity = 0
+
         # Net forces
-        Fx_net = Fx_drag + Fx_thrust
-        Fy_net = Fy_drag + Fy_thrust + (-m * g_local)
+        Fx_net = Fx_drag + Fx_thrust + Fx_gravity
+        Fy_net = Fy_drag + Fy_thrust + Fy_gravity
 
         # Accelerations
         ax = Fx_net / m
diff --git a/solver.py b/solver.py
index dbc0da9..4902f10 100644
--- a/solver.py
+++ b/solver.py
@@ -4,6 +4,7 @@
 from physics import Rocket
 import numpy as np
 import matplotlib.pyplot as plt
+import copy
 
 
 class Solver():
@@ -17,8 +18,9 @@ class Solver():
         self.tend = tend
         self.min_its = min_its
         self.max_its = max_its
+        self.rocket_dropped = False
 
-    def solve_singlestep(f, tn, un, h):
+    def solve_singlestep(self, f, tn, un, h):
         """
         Perform one step of the fourth order Runge-Kutta
 
@@ -37,6 +39,9 @@ class Solver():
         k3 = f(tn + h/2, un + k2*h/2)
         k4 = f(tn + h, un + k3*h)
         un1 = un + h/6 * (k1 + 2*k2 + 2*k3 + k4)
+        if (tn > Rocket().t_b_n and not self.rocket_dropped and f == Rocket().Nike_Apache_physics):
+            un1[4] -= (un[4] - Rocket().Mp_a)
+            self.rocket_dropped = True
         return un1
 
     def solve_general(self, u_0, f, T, N):
@@ -52,13 +57,14 @@ class Solver():
         Output:
         - (u_n): a matrix (np.array) of size (N+1, d).
         """
-
+        self.rocket_dropped = False
         h = T/N
         d = u_0.shape[0]
-        u = np.zeros((N+1, d))
+        u = np.zeros((N, d))
         u[0] = u_0
-        for n in range(N):
-            u[n+1] = Solver.solve_singlestep(f, n*h, u[n], h)
+
+        for n in range(N - 1):
+            u[n+1] = self.solve_singlestep(f, n*h, u[n], h)
 
         return u
 
@@ -88,15 +94,15 @@ class Solver():
 
         result = self.solve_general(args, rocket.rocket_1d_dynamics, T, N//2)
         result_2 = self.solve_general(args, rocket.rocket_1d_dynamics, T, N)
-        mymax = np.max(np.abs(np.repeat(result, repeats=2, axis=0)[:-1] - result_2))
+        mymax = np.max(np.abs(np.repeat(result, repeats=2, axis=0) - result_2))
 
         while (mymax >= self.eps and 2 * N < self.max_its):
             print(f"Desired tolerance not reached, increasing number of \
                   interpolation points to {N} and current maximum error is {mymax}")
             N *= 2
             result = result_2
-            result_2 = Solver.solve_general(args, rocket.rocket_1d_dynamics, T, N)
-        return np.asarray((np.repeat(result, repeats=2, axis=0)[:-1], result_2))
+            result_2 = self.solve_general(args, rocket.rocket_1d_dynamics, T, N)
+        return np.asarray((np.repeat(result, repeats=2, axis=0), result_2))
 
     def solve_rocket2d(self, rocket):
         """
@@ -124,51 +130,45 @@ class Solver():
         T = self.tend-self.tbegin  # Total run time.
         N = int(self.min_its)  # Steps
 
-        result = self.solve_general(args, rocket.rocket_2d_dynamics, T, N//2)
+        result = self.solve_general(args, rocket.rocket_2d_dynamics, T, N // 2)
         result_2 = self.solve_general(args, rocket.rocket_2d_dynamics, T, N)
-        mymax = np.max(np.abs(np.repeat(result, repeats=2, axis=0)[:-1] - result_2))
 
+        mymax = np.max(np.abs(np.repeat(result, repeats=2, axis=0) - result_2))
         while (mymax >= self.eps and 2 * N < self.max_its):
             print(f"Desired tolerance not reached, increasing number of \
                   interpolation points to {N} and current maximum error is {mymax}")
             N *= 2
             result = result_2
-            result_2 = Solver.solve_general(args, rocket.rocket_2d_dynamics, T, N)
-        return_list = np.asarray((np.repeat(result, repeats=2, axis=0)[:-1], result_2))
+            result_2 = self.solve_general(args, rocket.rocket_2d_dynamics, T, N)
+        return_list = np.asarray((np.repeat(result, repeats=2, axis=0), result_2))
         return np.asarray([[(item[0], item[1],
                              np.sqrt(item[2]**2 + item[3]**2), item[4])
                              for item in result]
                              for result in return_list])
 
 
-if __name__ == "__main__":
-    rocket = Rocket(la=90)
-    solver = Solver()
-    result = solver.solve_rocket2d(rocket)
-
-    print(result.shape, end="\n\n")
-
-    print(result[0], result[1])
-
-    distance = result[0][:, 0].reshape(1, -1)[0]
-    altitude = result[0][:, 1].reshape(1, -1)[0]
-    velocity = result[0][:, 2].reshape(1, -1)[0]
-    mass = result[0][:, 3].reshape(1, -1)[0]
-
-    print("number of close alt and dist = ", len([abs(dis - alt) < 1 for dis, alt in zip(distance, altitude)]))
-
-    T = solver.tend - solver.tbegin
-    x = np.linspace(0, T, len(altitude) - 1)
-
-    fig, ax = plt.subplots(2, 2, figsize=(10, 8))
-    ax[0][0].plot(x, altitude[:-1], label="Altitude")
-    ax[0][0].plot(x, velocity[:-1], label="Velocity")
-    ax[0][1].plot(x, mass[:-1], label="Mass")
-    ax[1][0].plot(velocity, altitude)
-    ax[1][0].set_xlabel("Velocity")
-    ax[1][0].set_ylabel("Altitude")
-    ax[0][0].legend()
-    ax[1][1].plot(distance, altitude)
-    ax[1][1].set_xlabel("distance")
-    ax[1][1].set_ylabel("altitude")
-    plt.show()
+#if __name__ == "__main__":
+#    rocket = Rocket(la=85)
+#    solver = Solver(tend=500)
+#    result = solver.solve_rocket2d(rocket)
+#
+#    distance = result[0][:, 0].reshape(1, -1)[0]
+#    altitude = result[0][:, 1].reshape(1, -1)[0]
+#    velocity = result[0][:, 2].reshape(1, -1)[0]
+#    mass = result[0][:, 3].reshape(1, -1)[0]
+#
+#    T = solver.tend - solver.tbegin
+#    x = np.linspace(0, T, len(altitude) - 1)
+#
+#    fig, ax = plt.subplots(2, 2, figsize=(10, 8))
+#    ax[0][0].plot(x, altitude[:-1], label="Altitude")
+#    ax[0][0].plot(x, velocity[:-1], label="Velocity")
+#    ax[0][1].plot(x, mass[:-1], label="Mass")
+#    ax[1][0].plot(velocity, altitude)
+#    ax[1][0].set_xlabel("Velocity")
+#    ax[1][0].set_ylabel("Altitude")
+#    ax[0][0].legend()
+#    ax[1][1].plot(distance, altitude)
+#    ax[1][1].set_xlabel("distance")
+#    ax[1][1].set_ylabel("altitude")
+#    plt.show()
diff --git a/verifier.py b/verifier.py
index aa77a95..89e8a6a 100644
--- a/verifier.py
+++ b/verifier.py
@@ -153,51 +153,50 @@ class Verifier():
         pass
 
 
-#if __name__ == "__main__":
-#    currocket = Rocket()
-#    # currocket.Mp = 755.0
-#    # currocket.t_b = 3.5
-#    # currocket.Mr = 0
-#    # with open("ValidationSets/NASA data/rocket_mass.txt") as file:
-#    #     for line in file:
-#    #         currocket.Mr += float(line)
-#    # currocket.T = 22820
-#    # currocket.Cd = 0.5 # See page 10.
-#    # currocket.A =
-#    # currocket.I_sp =
-#
-#    mysolver = Solver()
-#    mysolver.tbegin = 0
-#    mysolver.tend = 16
-#
-#    # Rotate the two models around their axes.
-#    sol = mysolver.solve_rocket2d(currocket)
-#    print(np.shape(sol))
-#    modeldata = np.transpose(sol, [0, 2, 1])
-#    # print(np.transpose(sol, [0, 2, 1]).shape)
-#    plotdata = ((modeldata[0][1], modeldata[0][0]), (modeldata[1][1], modeldata[1][0]))
-#    # print(np.shape(modeldata))
-#    verificationdata = (pd.read_csv("ValidationSets/NASA data/Flight path data.csv").
-#                        sort_values(by=["Altitude (thousands of feet)"])).to_numpy()
-#    verificationdata = (verificationdata.T)[1:]
-#    print(np.shape(verificationdata))
-#    Verifier.PlotData(np.array(plotdata)/1000, verificationdata, "Speed (thousands of feet per second)", "Altitude (thousands of feet)", savefig=False)
-#    # modeldata = mysolver.solve_rocket(currocket).T
-#    # modeldata = [modeldata[1], modeldata[0]]
-#    # print(np.shape(modeldata))
-#    # verificationdata = (pd.read_csv("ValidationSets/NASA data/Flight path data.csv").
-#    #                     sort_values(by=["Altitude (thousands of feet)"])).to_numpy()
-#    # verificationdata = (verificationdata.T)[1:]
-#    # print(np.shape(verificationdata))
-#    # # print(verificationdata)
-#    # Verifier.PlotData(np.array(modeldata)/1000, verificationdata, "Speed (thousands of feet per second)", "Altitude (thousands of feet)", savefig=False)
-#    # # Verifier.PlotData(np.array(modeldata)/1000, , "Speed (thousands of feet per second)", "Altitude (thousands of feet)", savefig=False)
-#
-#
-#    # Verifier.DataCreator("ValidationSets/NASA data/Flight path data.png",
-#    #                      "ValidationSets/NASA data/Flight path data.csv",
-#    #                      {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7},
-#    #                      {0: 200, 1: 150, 2: 100, 3: 50, 4: 0},
-#    #                      xlabel="Speed (thousands of feet per second)",
-#    #                      ylabel="Altitude (thousands of feet)")
-#
\ No newline at end of file
+if __name__ == "__main__":
+    currocket = Rocket()
+    # currocket.Mp = 755.0
+    # currocket.t_b = 3.5
+    # currocket.Mr = 0
+    # with open("ValidationSets/NASA data/rocket_mass.txt") as file:
+    #     for line in file:
+    #         currocket.Mr += float(line)
+    # currocket.T = 22820
+    # currocket.Cd = 0.5 # See page 10.
+    # currocket.A =
+    # currocket.I_sp =
+
+    mysolver = Solver()
+    mysolver.tbegin = 0
+    mysolver.tend = 16
+
+    # Rotate the two models around their axes.
+    sol = mysolver.solve_rocket2d(currocket)
+    print(np.shape(sol))
+    modeldata = np.transpose(sol, [0, 2, 1])
+    # print(np.transpose(sol, [0, 2, 1]).shape)
+    plotdata = ((modeldata[0][2], np.sqrt(modeldata[0][1]**2 + modeldata[0][0]**2)), (modeldata[1][2], np.sqrt(modeldata[1][1]**2 + modeldata[1][0]**2)))
+    # print(np.shape(modeldata))
+    verificationdata = (pd.read_csv("ValidationSets/NASA data/Flight path data.csv").
+                        sort_values(by=["Altitude (thousands of feet)"])).to_numpy()
+    verificationdata = (verificationdata.T)[1:]
+    print(np.shape(verificationdata))
+    Verifier.PlotData(np.array(plotdata)/1000, verificationdata, "Speed (thousands of feet per second)", "Altitude (thousands of feet)", savefig=False)
+    # modeldata = mysolver.solve_rocket(currocket).T
+    # modeldata = [modeldata[1], modeldata[0]]
+    # print(np.shape(modeldata))
+    # verificationdata = (pd.read_csv("ValidationSets/NASA data/Flight path data.csv").
+    #                     sort_values(by=["Altitude (thousands of feet)"])).to_numpy()
+    # verificationdata = (verificationdata.T)[1:]
+    # print(np.shape(verificationdata))
+    # # print(verificationdata)
+    # Verifier.PlotData(np.array(modeldata)/1000, verificationdata, "Speed (thousands of feet per second)", "Altitude (thousands of feet)", savefig=False)
+    # # Verifier.PlotData(np.array(modeldata)/1000, , "Speed (thousands of feet per second)", "Altitude (thousands of feet)", savefig=False)
+
+
+    # Verifier.DataCreator("ValidationSets/NASA data/Flight path data.png",
+    #                      "ValidationSets/NASA data/Flight path data.csv",
+    #                      {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7},
+    #                      {0: 200, 1: 150, 2: 100, 3: 50, 4: 0},
+    #                      xlabel="Speed (thousands of feet per second)",
+    #                      ylabel="Altitude (thousands of feet)")
